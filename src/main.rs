use std::fs::{OpenOptions};
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;
use confy::ConfyError;
use serde::{Deserialize, Serialize};
use clap::Parser;

const CONF_DIR_NAME:&str = "flatpak_aliaser";
const CONF_FILE_NAME:&str = "config";
const CONF_FILE_EXT:&str = ".toml";
const CONF_FILE_WARNING:&str =
r#"# Do not edit this file since it will be overwritten when the program is rerun.
# To change an alias or add options please change the config file at ~/.config/flatpak_aliaser/config.toml
"#;

const PRINT_BUILD_TYPE:bool = false;

#[derive(Serialize, Deserialize, Debug)]
struct Config {
    do_not_alias: Vec<String>,
    special_alias:Vec<(String, String, String)>,
    aliases_all_lowercase:bool,
    destination_path:String,
}

impl Default for  Config{
    fn default()->Self{
        let mut home_path = dirs::home_dir().unwrap().to_str().unwrap().to_string();
        home_path.push_str("/.flatpak_aliases");
        Config{
            do_not_alias: vec!["app.example.org".to_string()],
            special_alias: vec![("app.example.org".to_string(), "example".to_string()
                                 , "flatpak run app.example.org --some --options".to_string())],
            aliases_all_lowercase: true,
            destination_path: home_path ,
        }
    }
}

fn get_config_file_path() -> PathBuf {
    let mut config_dir:PathBuf;
    if cfg!(feature="flatpak"){
        // dirs does not work
        config_dir = dirs::home_dir().unwrap();
        config_dir.push(".config")
    }else {
        config_dir = dirs::config_dir().unwrap();
    }
    config_dir.push(CONF_DIR_NAME);
    config_dir.push(format!("{CONF_FILE_NAME}{CONF_FILE_EXT}"));
    return config_dir;
}

/// Program that creates aliases for installed flatpacks
/// the config is will be created at ~/.config/flatpak_aliaser/conf.toml
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Outfile (optional) the file where the generated aliases are saved.
    /// default is ~/.flatpak_aliases
    #[arg(short, long)]
    outfile:Option<String>,

//    /// Config (optional) config for alternate aliases
//    /// the default location is ~/.config/flatpak_aliaser/conf.toml
//    #[arg(short, long)]
//    config:Option<String>
}

fn main() {
    let args= Args::parse();

    if PRINT_BUILD_TYPE{
        if cfg!(feature="flatpak"){
            println!("flatpak build")
        }else {
            println!("regular build")
        }
    }

    let mut cmd = if cfg!(feature="flatpak"){
        Command::new("flatpak-spawn")
    }else {
        Command::new("flatpak")
    };
    if cfg!(feature="flatpak"){
        cmd.arg("--host");
        cmd.arg("flatpak");
    }

    cmd.arg("list")
        .arg("--app")
        .arg("--columns=application");

    let stdout =String::from_utf8(cmd.output()
        .expect("could list installed flatpak applications").stdout).unwrap();

    let config_file_path = get_config_file_path();
    let config_exists = Path::exists(config_file_path.as_path());
    let c :Result<Config,ConfyError> = confy::load_path(config_file_path.as_path());
    let conf:Config;

    if c.is_ok(){
        conf  = c.unwrap();
        if config_exists{
            println!("loaded config successfully");
            //println!("config:{:?}", conf)
        }else {
            println!("no config detected, creating new config with defaults");
        }
    }else {
        let err = c.err().unwrap();
        print!("could not load conf ");
        match err {
            ConfyError::BadTomlData(_) => {println!("bad toml data, there might be a typo")}
            ConfyError::DirectoryCreationFailed(_) => {println!("directory creation failed")}
            ConfyError::GeneralLoadError(_) => {println!("general load error")}
            ConfyError::BadConfigDirectory(_) => {println!("config directory not found")}
            ConfyError::SerializeTomlError(_) => {println!("serialisation failed, there might be a typo")}
            ConfyError::WriteConfigurationFileError(_) => {println!("write configuration error")}
            ConfyError::ReadConfigurationFileError(_) => {println!("read configuration error")}
            ConfyError::OpenConfigurationFileError(_) => {println!("open configuration error")}
            #[allow(unreachable_patterns)]
            _ => {println!("unknown error")}
        }
        println!("failed to load conf file, loading defaults");
        conf = Config::default();
    }

    let mut lines:Vec<_> =  stdout.split("\n").map(|e| e.to_string()).collect();
    lines.remove(lines.len()-1);
    let mut aliases:Vec<String> = vec![];
    for line in lines{
        let opt = standard_alias(&line, &conf);
        if opt.is_some(){
            aliases.push(opt.unwrap());
        }
    }

    let out_path = if args.outfile.is_none() {
        conf.destination_path.clone()
    }else {
        args.outfile.unwrap()
    };

    let mut out_file = OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(out_path)
        .unwrap();

    println!("writing to outfile");
    let _ =out_file.write(CONF_FILE_WARNING.as_bytes());
    for line in aliases{
        out_file.write(format!("{}\n", line).as_bytes()).unwrap();
    }
    println!("done")
}

fn standard_alias(app_id:&String, conf:&Config)-> Option<String>{
    if conf.do_not_alias.contains(app_id){
         return None
    }
    for special_tuple in &conf.special_alias{
        if special_tuple.0 == app_id.clone(){
            return Some(format!("alias {}='flatpak run {} {}'", special_tuple.1, app_id, special_tuple.2))
        }
    }
    let segments: Vec<_> =  app_id.split(".").map(|e| e.to_string()).collect();
    let mut app_name = segments[segments.len()-1].clone();
    if conf.aliases_all_lowercase {
        app_name = app_name.to_lowercase();
    }
    return Some(format!("alias {}='flatpak run {}'",app_name , app_id))
}